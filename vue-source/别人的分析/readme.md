#Vue 与 模板

使用步骤

1. 编写页面 模板
    1. 直接在HTML标签中写标签
    2. 使用template
    3. 使用单文件(<template/>)
2. 创建Vue的实例
    1.在Vue的构造函数中提供：data，method，computed，watcher，props,……
3. 将 vue 挂载 到页面中（$mount）

# 数据驱动模型

Vue的执行流程

1. 获得模板： 模板中有“坑”
2. 利用Vue 构造函数中所提供的数据来填“坑”，得到可以在页面中显示的“标签”
3. 将“标签”替换页面中原来有“坑”的的标签

Vue 利用我们提供的数据和页面中的模板 ， 生成了 一个新的 html 标签（node元素），
替换掉了 页面中 放置模板的位置。

>思考：该怎么实现？

    
## 虚拟dom
目标
1.怎么讲真正的dom转换成虚拟dom
2.怎么讲虚拟dom转换成真正的dom
思路和深拷贝类似

为什么要去使用虚拟dom？ 提高性能

## 函数科里化
函数式变成
维基百科

概念：
1.科里化：一个函数原本有多个参数，现在只传入一个参数，生成一个新函数，由新函数来接收剩下的参数来运行得到的结果。
2.偏函数：一个函数原本有多个参数，现在只传入一个参数，生成一部分新函数，由新函数来接收剩下的参数来运行得到的结果。
3.高阶函数：一个函数的参数是一个函数，该函数对参数这个函数进行加工，得到一个函数，这个加工用的函数就是高阶函数。

为什么要使用科里化？为了提升性能，使用科里化可以缓存一部分能力。
使用两个案例来说明：
1.判断元素
    Vue本质上市使用HTML字符串作为模板的，将字符串的模板转换成抽象语法树AST,再转换为 VNode.
    - 模板--->抽象语法数ast
    - 抽象语法树ast --->VNode
    - VNode ---> DOM
    
2.虚拟dom的render方法


## 判断元素
哪一个阶段最消耗性能？
    最消耗性能的是字符串解析（ 模板 -> ast）
    1.举个栗子：
    let s = "1 + 2 * (3 + 4)"
    写一个程序，解释这个表达式，得到结果（一般化）。（阿里的面试题）
        我们一般会将这个表达式转换成“波兰式”的表达式，然后使用栈结构来运算。
        
2.在我们的vue当中，每一个标签可以是真正的html标签，也可以是自定义组件，问怎么区分？？？
    在Vue源码中其实已经将所有可以用的HTML标签已经存起来了。
    
假设这里是考虑几个标签：
```
let tag = 'div,p,a,img,ul,li'.split(',');
```
需要一个函数，判断一个标签名是否为内置的标签

```
function isHTMLTag(tagName){
    tagName = tagName.toLowerCase();
    for( let i = 0; i< ...){
        if(tagName === tags[i]) return true;
    }
    return false;
    
}
```
注意：模板是任意编写的，可以写的很简单，也可以写的很复杂，indexOf 内部也是要循环的。
如果有6个内置标签，而模板中有10个标签需要判断，那么就需要执行60次循环。

## 虚拟dom的render方法
思考： Vue 项目 模板 转换成 抽象语法数需要执行几次？？？
1.页面一开始加载需要渲染
2.每一个属性（响应性）数据再发生变化的时候，要渲染
3.watch，computed 等等

我们昨天写的代码，每次需要渲染的时候，模板就会被解析一次（注意，这里我们简化了解析方法）
render的作用是将虚拟dom转换我真正的dom加到页面中
-优化虚拟dom可以降级理解为抽象语法数
-一个项目运行的时候，模板是不会变的，也就表示，抽象语法树是不会变的

我们可以将代码进行优化，将虚拟dom缓存起来，生成一个函数，函数只需要传入数据，就可以得到真正的dom。


## 响应式原理
```
Object.defineProperty(对象，'设置什么属性名',{
    writeable,
    configable,
    enumerable:用来控制属性是否可枚举
    set
    get
})
```

对于对象可以使用递归来响应式话，但是数组我们也需要处理
- push
- pop
- shift
- unshift
- reverse
- sort
- splice

要做什么事情呢？
1.改变数组的数据的时候，要发出通知
vue2中的缺陷，数组发生变化，设置length没法通知。（Vue3中使用Proxy 语法ES6 的语法解决了这个问题）
2.加入的元素应该变成响应式的
技巧： 如果一个函数已经定义了，但是我们需要扩展其功能，我们一般的处理办法：
1.使用一个临时的函数名来存储函数
2.重新定义原来的函数
3.定义扩展的功能
4.调用临时的那个函数

扩展数组的push 和 pop 怎么处理呢？？？
- 直接修改 prototype **不行**
- 修改要进行响应式话的数组的原型（__proto__）

## 代理的方法
就是要将app._data 中的成员映射到app上。
由于需要在更新数据的时候，更新页面的内容
所以app._data 访问的成员 与 app 访问的成员应该是同一个成员

由于app._data 已经是响应式的对象了，所以只需要让app访问的成员去访问app._data的对应成员就可以了

例如
```html
app.name 转换成 app._data.name
app.xxx 转换成 app._data.xxx

```

引入一个函数proxy(target, src, prop)
将target的操作映射到 src.prop 上这里是因为当时没有 `proxy` 语法（es6）

我们之前处理的rectify的方法已经不行了，我们需要一个新的方法来处理

提供一个Observer额方法，在方法中对属性进行处理
可以将这个方法添加到initData方法中。

## 解析proxy
```js
app._data.name
// vue涉及，不希望访问 _ 开头的数据
// vue中有一个潜规则：
//  -_开头的数据是私有数据
//  -$开头的是只读数据
app.name
// 将 对 _data.xxx 的访问交给了 实例

// 重点： 访问app 的xxx就是在访问 app._data.xxx
```

假设：
```js

var o1 = {name:'张三'};
//要有一个对象o2, 在访问o2.name的时候想要访问的是o1.name
Object.defineProperty(o2, 'name', {
    get(){
        return o1.name
    }
});

```

访问app的xxx就是在访问 app._data.xxx
```js
Object.defineProperty( app, 'name', {
    get(){
        return app._data.name
    },
    set( newVal ){
        app._data.name = newVal;
    }
});
```

将属性的操作转换成参数
```js
function proxy( app ,key ){
    Object.defineProperty( app, key , {
        get(){
            return app._data[key];
        },
        set(){
            app._data[key] = newVal;
        }
    })
}
```
问题：

在vue中不仅仅是只有 data 属性，properties 等等都会挂载到Vue实例上

```js
function proxy( app, prop, key){
    Object.defineProperty( app, key, {
        get(){
            return app[ prop ][ key ];
        },
        set( newVal ){
            app[ prop ][ key ] = newVal;
        }
    })
}

// 如果将_data 的成员映射到实力上
proxy( 实例， '_data', 属性名)

// 如果要 _properties 的成员映射到 实例上
proxy( 实例， '_properties', 属性名)
```


## 事件模型（）

## 发布订阅模式
目的： 解耦，让各个模块之间没有紧密的联系
现在的处理办法是 属性在更新的时候 调用mountComponent 方法

问题：mountComponent 更新的是什么？ ？？
现在更新的是全部的页面  
--》 当前虚拟doom 对应的页面dom

在vue中，整个的更新是按照组件为单位进行 **判断** ，以节点为单位进行更新

- 如果我们的代码当中没有自定义的组件，那么在比较算法的时候，我们会将全部的模板 对应的 虚拟dom 进行比较，
- 如果我们的代码中含有自定义组件，那么在比较算法的时候，就会判断更新的是哪一些组件中的属性，只会判断更新数据的组件，
其他组件不会更新。

** 目标，如果修改了什么属性，就尽可能只更新这些属性对应的页面dom **
这样就一定不能将更新的代码写死。

例子：预售可能一个东西没有现货，告诉老板，如果东西到了就告诉我
老板就是发布者
订阅什么东西作为中间媒介
我就是订阅者

使用代码结构来描述：
1. 老板提供一个账簿（数组）
2. 我可以根据需求订阅我的商品（老板要记录下谁定了什么东西，在数组中存储某些东西）
3. 等待，可以做其他的事情
4. 当货品来到的时候，老板就查看账簿，挨个打电话（遍历数组，取出数组里的元素来使用）

实际上就是事件模型
1. 有一个 event 对象
2. on,off,emit方法

实现事件模型，思考怎么用？
1.event 是一个全局对象
2.event。on('事件名'，处理函数)，订阅时间
    + 事件可以连续订阅
    + 可以移除：evnet.off()
        移除所有
        移除某一个类型的时间
        移除某一个类型的某一个处理函数
3.写别的代码
4.event.emit('事件名'，参数)，先前注册的时间处理函数就会依次调用

原因：
1.描述发布订阅模式
2.后面会使用到事件

## 发布订阅模式（形式不局限于函数，形式可以是对象等）
1. 中间的全局的容器，用来存储可以被触发的东西（函数，对象）
2. 需要一个方法，可以往容器中传入东西（ 函数，对象）
3. 需要一个方法，可以将容器中的东西取出来使用（函数调用，对象的方法调用）

Vue模型
-如果页面中只有一个组件（Vue实例），不会有性能损失
-但是如果页面中有多个组件（多watcher 的情况），第一次会有多个组件的watcher存入到全局watcher中
    - 如果修改了局部的数据，例如其中一个组件的数据，
    - 表示只会对该组件进行diff算法，也就是说只会从重新生成该组件的语法抽象树
    - 也就表示只会访问该组件的watcher，
    - 也就表示再次往全局存储的只有该组件的watcher
    - 页面更新的时候也就只需要更新一部分

## Watcher 与 Dep
之前将渲染Watcher放在全局作用域上，这样处理是有问题的。
- Vue项目中包含很多的组件，各个组件是**自治**的
    -那么watcher就可能有多个
    -每一个watcher用于描述一个渲染行为 或 计算行为
      - 子组件发生的数据更新，页面需要重新渲染（真正的Vue是**局部**渲染）
      - 例如Vue中推荐的是使用计算属性代表复杂的表达式
        - 计算属性是会伴随其使用的属性变化而变化
        - `name: () => this.first + this.lastName`
            - 计算属 依赖于 属性first 和 属性lastName
            - 只要被依赖的属性发生变化，那么就会促使计算属性**重新计算**（watcher）
            
> 依赖收集与派发更新是怎么运行起来的
**我们在访问的时候 就会进行收集，在修改的时候就会更新，那么收集什么就更新什么**

所谓的依赖收集**实际上就是告诉当前的wacher 什么属性被访问了**
那么在这个watcher计算的时候，或渲染页面的时候，就会将这些收集到的属性进行更新

如何将我们的属性与当前watcher关联起来？？
- 在全局 准备一个 targetStack（指的是我们的watcher栈，简单理解为watcher “数组”，把一个操作所以用到的watcher都存储起来）   
- 在watcher调用get方法的时候，将当前watcher 放到全局，在get() 之前结束的会后，将这个 全局的watcher 移除。提供pushTarget，popTarget
- 在每一个属性中，都有一个dep对象 

我们在访问对象属性的时候（get），我们的渲染watcher就在全局中
> 将我们的属性与watcher关联，其实就是将当前渲染的watcher 存储到属性相关的 dep中
同时将 dep 也存储到 当前全局的watcher中，（互相引用的关系）

- 属性 引用了 当前的渲染watcher，属性知道，谁在渲染它
- 当前渲染watcher 引用了 访问的属性（Dep），当前的watcher知道渲染了什么属性   （这里没毛病）

我们的dep 有一个方法，叫notify()
- 内部就是将dep中的subs取出来，一次调用其update方法
- subs中存储的是 ** 知道要渲染什么属性的watcher **





## 各个文件夹的作用
1. compiler编译用的
    -vue 使用 字符串作为模板
    -在编译文件夹中存放对模板字符串的解析的算法，抽象语法树，优化等
2. core核心，vue 构造函数，以及生命周期等方法的部分
3. platforms 平台
    - 针对运行的 环境 （设备），有不同的实现
    - 也是vue的入口
4. server 服务端，主要是将我们的vue用在服务端的处理 （略）
5. sfc，单文件组件，（略）
6. shared 公共工具，方法

## observer 文件夹中各个文件的作用
-array.js 创建含有重写 数组方法的数组，让所有的响应式数据数组继承自该数组
-dep.js Dep类
-index.js Observer类，observe的工厂函数
-scheduler.js vue中的任务调度的工具，watcher执行的核心
-traverse.js 递归遍历响应式数据，目的是触发依赖收集。



## 改写observe 函数
缺陷：
- 无法处理数组
- 响应式无法在中间继承watcher处理
- 我们实现的 recify 需要和实例静静的绑定在一起，分离（解耦）

## 问题
-observe 还没对单独的数组元素做处理吧？

## 引入watcher
问题
- 模型（图）
- 关于this的问题



